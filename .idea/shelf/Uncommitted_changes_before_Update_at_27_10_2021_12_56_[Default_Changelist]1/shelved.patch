Index: FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/internal/FtcRobotControllerActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2014, 2015 Qualcomm Technologies Inc\r\n\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without modification,\r\nare permitted (subject to the limitations in the disclaimer below) provided that\r\nthe following conditions are met:\r\n\r\nRedistributions of source code must retain the above copyright notice, this list\r\nof conditions and the following disclaimer.\r\n\r\nRedistributions in binary form must reproduce the above copyright notice, this\r\nlist of conditions and the following disclaimer in the documentation and/or\r\nother materials provided with the distribution.\r\n\r\nNeither the name of Qualcomm Technologies Inc nor the names of its contributors\r\nmay be used to endorse or promote products derived from this software without\r\nspecific prior written permission.\r\n\r\nNO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\nLICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\r\n\r\npackage org.firstinspires.ftc.robotcontroller.internal;\r\n\r\nimport android.app.ActionBar;\r\nimport android.app.Activity;\r\nimport android.app.ActivityManager;\r\nimport android.content.ComponentName;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.content.ServiceConnection;\r\nimport android.content.SharedPreferences;\r\nimport android.content.res.Configuration;\r\nimport android.content.res.Resources;\r\nimport android.hardware.usb.UsbDevice;\r\nimport android.hardware.usb.UsbManager;\r\nimport android.net.wifi.WifiManager;\r\nimport android.os.Bundle;\r\nimport android.os.IBinder;\r\nimport android.preference.PreferenceManager;\r\nimport androidx.annotation.NonNull;\r\nimport androidx.annotation.Nullable;\r\nimport androidx.annotation.StringRes;\r\nimport android.view.Menu;\r\nimport android.view.MenuItem;\r\nimport android.view.MotionEvent;\r\nimport android.view.View;\r\nimport android.view.WindowManager;\r\nimport android.webkit.WebView;\r\nimport android.widget.ImageButton;\r\nimport android.widget.LinearLayout;\r\nimport android.widget.LinearLayout.LayoutParams;\r\nimport android.widget.PopupMenu;\r\nimport android.widget.TextView;\r\n\r\nimport com.acmerobotics.dashboard.FtcDashboard;\r\nimport com.google.blocks.ftcrobotcontroller.ProgrammingWebHandlers;\r\nimport com.google.blocks.ftcrobotcontroller.runtime.BlocksOpMode;\r\nimport com.qualcomm.ftccommon.ClassManagerFactory;\r\nimport com.qualcomm.ftccommon.FtcAboutActivity;\r\nimport com.qualcomm.ftccommon.FtcEventLoop;\r\nimport com.qualcomm.ftccommon.FtcEventLoopIdle;\r\nimport com.qualcomm.ftccommon.FtcRobotControllerService;\r\nimport com.qualcomm.ftccommon.FtcRobotControllerService.FtcRobotControllerBinder;\r\nimport com.qualcomm.ftccommon.FtcRobotControllerSettingsActivity;\r\nimport com.qualcomm.ftccommon.LaunchActivityConstantsList;\r\nimport com.qualcomm.ftccommon.LaunchActivityConstantsList.RequestCode;\r\nimport com.qualcomm.ftccommon.Restarter;\r\nimport com.qualcomm.ftccommon.UpdateUI;\r\nimport com.qualcomm.ftccommon.configuration.EditParameters;\r\nimport com.qualcomm.ftccommon.configuration.FtcLoadFileActivity;\r\nimport com.qualcomm.ftccommon.configuration.RobotConfigFile;\r\nimport com.qualcomm.ftccommon.configuration.RobotConfigFileManager;\r\nimport com.qualcomm.ftcrobotcontroller.BuildConfig;\r\nimport com.qualcomm.ftcrobotcontroller.R;\r\nimport com.qualcomm.hardware.HardwareFactory;\r\nimport com.qualcomm.robotcore.eventloop.EventLoopManager;\r\nimport com.qualcomm.robotcore.eventloop.opmode.FtcRobotControllerServiceState;\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpModeRegister;\r\nimport com.qualcomm.robotcore.hardware.configuration.LynxConstants;\r\nimport com.qualcomm.robotcore.hardware.configuration.Utility;\r\nimport com.qualcomm.robotcore.robot.Robot;\r\nimport com.qualcomm.robotcore.robot.RobotState;\r\nimport com.qualcomm.robotcore.util.Device;\r\nimport com.qualcomm.robotcore.util.Dimmer;\r\nimport com.qualcomm.robotcore.util.ImmersiveMode;\r\nimport com.qualcomm.robotcore.util.RobotLog;\r\nimport com.qualcomm.robotcore.util.WebServer;\r\nimport com.qualcomm.robotcore.wifi.NetworkConnection;\r\nimport com.qualcomm.robotcore.wifi.NetworkConnectionFactory;\r\nimport com.qualcomm.robotcore.wifi.NetworkType;\r\n\r\nimport org.firstinspires.ftc.ftccommon.external.SoundPlayingRobotMonitor;\r\nimport org.firstinspires.ftc.ftccommon.internal.FtcRobotControllerWatchdogService;\r\nimport org.firstinspires.ftc.ftccommon.internal.ProgramAndManageActivity;\r\nimport org.firstinspires.ftc.onbotjava.OnBotJavaHelperImpl;\r\nimport org.firstinspires.ftc.onbotjava.OnBotJavaProgrammingMode;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.MotionDetection;\r\nimport org.firstinspires.ftc.robotcore.internal.hardware.android.AndroidBoard;\r\nimport org.firstinspires.ftc.robotcore.internal.network.DeviceNameManagerFactory;\r\nimport org.firstinspires.ftc.robotcore.internal.network.PreferenceRemoterRC;\r\nimport org.firstinspires.ftc.robotcore.internal.network.StartResult;\r\nimport org.firstinspires.ftc.robotcore.internal.network.WifiDirectChannelChanger;\r\nimport org.firstinspires.ftc.robotcore.internal.network.WifiMuteEvent;\r\nimport org.firstinspires.ftc.robotcore.internal.network.WifiMuteStateMachine;\r\nimport org.firstinspires.ftc.robotcore.internal.opmode.ClassManager;\r\nimport org.firstinspires.ftc.robotcore.internal.system.AppAliveNotifier;\r\nimport org.firstinspires.ftc.robotcore.internal.system.AppUtil;\r\nimport org.firstinspires.ftc.robotcore.internal.system.Assert;\r\nimport org.firstinspires.ftc.robotcore.internal.system.PreferencesHelper;\r\nimport org.firstinspires.ftc.robotcore.internal.system.ServiceController;\r\nimport org.firstinspires.ftc.robotcore.internal.ui.ThemedActivity;\r\nimport org.firstinspires.ftc.robotcore.internal.ui.UILocation;\r\nimport org.firstinspires.ftc.robotcore.internal.webserver.RobotControllerWebInfo;\r\nimport org.firstinspires.ftc.robotserver.internal.programmingmode.ProgrammingModeManager;\r\nimport org.firstinspires.inspection.RcInspectionActivity;\r\n\r\nimport java.util.List;\r\nimport java.util.Queue;\r\nimport java.util.concurrent.ConcurrentLinkedQueue;\r\n\r\n@SuppressWarnings(\"WeakerAccess\")\r\npublic class FtcRobotControllerActivity extends Activity\r\n  {\r\n  public static final String TAG = \"RCActivity\";\r\n  public String getTag() { return TAG; }\r\n\r\n  private static final int REQUEST_CONFIG_WIFI_CHANNEL = 1;\r\n  private static final int NUM_GAMEPADS = 2;\r\n\r\n  protected WifiManager.WifiLock wifiLock;\r\n  protected RobotConfigFileManager cfgFileMgr;\r\n\r\n  protected ProgrammingModeManager programmingModeManager;\r\n\r\n  protected UpdateUI.Callback callback;\r\n  protected Context context;\r\n  protected Utility utility;\r\n  protected StartResult prefRemoterStartResult = new StartResult();\r\n  protected StartResult deviceNameStartResult = new StartResult();\r\n  protected PreferencesHelper preferencesHelper;\r\n  protected final SharedPreferencesListener sharedPreferencesListener = new SharedPreferencesListener();\r\n\r\n  protected ImageButton buttonMenu;\r\n  protected TextView textDeviceName;\r\n  protected TextView textNetworkConnectionStatus;\r\n  protected TextView textRobotStatus;\r\n  protected TextView[] textGamepad = new TextView[NUM_GAMEPADS];\r\n  protected TextView textOpMode;\r\n  protected TextView textErrorMessage;\r\n  protected ImmersiveMode immersion;\r\n\r\n  protected UpdateUI updateUI;\r\n  protected Dimmer dimmer;\r\n  protected LinearLayout entireScreenLayout;\r\n\r\n  protected FtcRobotControllerService controllerService;\r\n  protected NetworkType networkType;\r\n\r\n  protected FtcEventLoop eventLoop;\r\n  protected Queue<UsbDevice> receivedUsbAttachmentNotifications;\r\n\r\n  protected WifiMuteStateMachine wifiMuteStateMachine;\r\n  protected MotionDetection motionDetection;\r\n\r\n  private static boolean permissionsValidated = false;\r\n\r\n  private WifiDirectChannelChanger wifiDirectChannelChanger;\r\n\r\n  protected class RobotRestarter implements Restarter {\r\n\r\n    public void requestRestart() {\r\n      requestRobotRestart();\r\n    }\r\n\r\n  }\r\n\r\n  protected boolean serviceShouldUnbind = false;\r\n  protected ServiceConnection connection = new ServiceConnection() {\r\n    @Override\r\n    public void onServiceConnected(ComponentName name, IBinder service) {\r\n      FtcRobotControllerBinder binder = (FtcRobotControllerBinder) service;\r\n      onServiceBind(binder.getService());\r\n    }\r\n\r\n    @Override\r\n    public void onServiceDisconnected(ComponentName name) {\r\n      RobotLog.vv(FtcRobotControllerService.TAG, \"%s.controllerService=null\", TAG);\r\n      controllerService = null;\r\n    }\r\n  };\r\n\r\n  @Override\r\n  protected void onNewIntent(Intent intent) {\r\n    super.onNewIntent(intent);\r\n\r\n    if (UsbManager.ACTION_USB_DEVICE_ATTACHED.equals(intent.getAction())) {\r\n      UsbDevice usbDevice = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);\r\n      RobotLog.vv(TAG, \"ACTION_USB_DEVICE_ATTACHED: %s\", usbDevice.getDeviceName());\r\n\r\n      if (usbDevice != null) {  // paranoia\r\n        // We might get attachment notifications before the event loop is set up, so\r\n        // we hold on to them and pass them along only when we're good and ready.\r\n        if (receivedUsbAttachmentNotifications != null) { // *total* paranoia\r\n          receivedUsbAttachmentNotifications.add(usbDevice);\r\n          passReceivedUsbAttachmentsToEventLoop();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  protected void passReceivedUsbAttachmentsToEventLoop() {\r\n    if (this.eventLoop != null) {\r\n      for (;;) {\r\n        UsbDevice usbDevice = receivedUsbAttachmentNotifications.poll();\r\n        if (usbDevice == null)\r\n          break;\r\n        this.eventLoop.onUsbDeviceAttached(usbDevice);\r\n      }\r\n    }\r\n    else {\r\n      // Paranoia: we don't want the pending list to grow without bound when we don't\r\n      // (yet) have an event loop\r\n      while (receivedUsbAttachmentNotifications.size() > 100) {\r\n        receivedUsbAttachmentNotifications.poll();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * There are cases where a permission may be revoked and the system restart will restart the\r\n   * FtcRobotControllerActivity, instead of the launch activity.  Detect when that happens, and throw\r\n   * the device back to the permission validator activity.\r\n   */\r\n  protected boolean enforcePermissionValidator() {\r\n    if (!permissionsValidated) {\r\n      RobotLog.vv(TAG, \"Redirecting to permission validator\");\r\n      Intent permissionValidatorIntent = new Intent(AppUtil.getDefContext(), PermissionValidatorWrapper.class);\r\n      startActivity(permissionValidatorIntent);\r\n      finish();\r\n      return true;\r\n    } else {\r\n      RobotLog.vv(TAG, \"Permissions validated already\");\r\n      return false;\r\n    }\r\n  }\r\n\r\n  public static void setPermissionsValidated() {\r\n    permissionsValidated = true;\r\n  }\r\n\r\n  @Override\r\n  protected void onCreate(Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n\r\n    if (enforcePermissionValidator()) {\r\n      return;\r\n    }\r\n\r\n    RobotLog.onApplicationStart();  // robustify against onCreate() following onDestroy() but using the same app instance, which apparently does happen\r\n    RobotLog.vv(TAG, \"onCreate()\");\r\n    ThemedActivity.appAppThemeToActivity(getTag(), this); // do this way instead of inherit to help AppInventor\r\n\r\n    // Oddly, sometimes after a crash & restart the root activity will be something unexpected, like from the before crash? We don't yet understand\r\n    RobotLog.vv(TAG, \"rootActivity is of class %s\", AppUtil.getInstance().getRootActivity().getClass().getSimpleName());\r\n    RobotLog.vv(TAG, \"launchActivity is of class %s\", FtcRobotControllerWatchdogService.launchActivity());\r\n    Assert.assertTrue(FtcRobotControllerWatchdogService.isLaunchActivity(AppUtil.getInstance().getRootActivity()));\r\n    Assert.assertTrue(AppUtil.getInstance().isRobotController());\r\n\r\n    // Quick check: should we pretend we're not here, and so allow the Lynx to operate as\r\n    // a stand-alone USB-connected module?\r\n    if (LynxConstants.isRevControlHub()) {\r\n      // Double-sure check that we can talk to the DB over the serial TTY\r\n      AndroidBoard.getInstance().getAndroidBoardIsPresentPin().setState(true);\r\n    }\r\n\r\n    context = this;\r\n    utility = new Utility(this);\r\n\r\n    DeviceNameManagerFactory.getInstance().start(deviceNameStartResult);\r\n\r\n    PreferenceRemoterRC.getInstance().start(prefRemoterStartResult);\r\n\r\n    receivedUsbAttachmentNotifications = new ConcurrentLinkedQueue<UsbDevice>();\r\n    eventLoop = null;\r\n\r\n    setContentView(R.layout.activity_ftc_controller);\r\n\r\n    preferencesHelper = new PreferencesHelper(TAG, context);\r\n    preferencesHelper.writeBooleanPrefIfDifferent(context.getString(R.string.pref_rc_connected), true);\r\n    preferencesHelper.getSharedPreferences().registerOnSharedPreferenceChangeListener(sharedPreferencesListener);\r\n\r\n    entireScreenLayout = (LinearLayout) findViewById(R.id.entire_screen);\r\n    buttonMenu = (ImageButton) findViewById(R.id.menu_buttons);\r\n    buttonMenu.setOnClickListener(new View.OnClickListener() {\r\n      @Override\r\n      public void onClick(View v) {\r\n        PopupMenu popupMenu = new PopupMenu(FtcRobotControllerActivity.this, v);\r\n        popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\r\n          @Override\r\n          public boolean onMenuItemClick(MenuItem item) {\r\n            return onOptionsItemSelected(item); // Delegate to the handler for the hardware menu button\r\n          }\r\n        });\r\n        popupMenu.inflate(R.menu.ftc_robot_controller);\r\n        FtcDashboard.populateMenu(popupMenu.getMenu());\r\n        popupMenu.show();\r\n      }\r\n    });\r\n\r\n    updateMonitorLayout(getResources().getConfiguration());\r\n\r\n    BlocksOpMode.setActivityAndWebView(this, (WebView) findViewById(R.id.webViewBlocksRuntime));\r\n\r\n    /*\r\n     * Paranoia as the ClassManagerFactory requires EXTERNAL_STORAGE permissions\r\n     * and we've seen on the DS where the finish() call above does not short-circuit\r\n     * the onCreate() call for the activity and then we crash here because we don't\r\n     * have permissions. So...\r\n     */\r\n    if (permissionsValidated) {\r\n      ClassManager.getInstance().setOnBotJavaClassHelper(new OnBotJavaHelperImpl());\r\n      ClassManagerFactory.registerFilters();\r\n      ClassManagerFactory.processAllClasses();\r\n    }\r\n\r\n    cfgFileMgr = new RobotConfigFileManager(this);\r\n\r\n    // Clean up 'dirty' status after a possible crash\r\n    RobotConfigFile configFile = cfgFileMgr.getActiveConfig();\r\n    if (configFile.isDirty()) {\r\n      configFile.markClean();\r\n      cfgFileMgr.setActiveConfig(false, configFile);\r\n    }\r\n\r\n    textDeviceName = (TextView) findViewById(R.id.textDeviceName);\r\n    textNetworkConnectionStatus = (TextView) findViewById(R.id.textNetworkConnectionStatus);\r\n    textRobotStatus = (TextView) findViewById(R.id.textRobotStatus);\r\n    textOpMode = (TextView) findViewById(R.id.textOpMode);\r\n    textErrorMessage = (TextView) findViewById(R.id.textErrorMessage);\r\n    textGamepad[0] = (TextView) findViewById(R.id.textGamepad1);\r\n    textGamepad[1] = (TextView) findViewById(R.id.textGamepad2);\r\n    immersion = new ImmersiveMode(getWindow().getDecorView());\r\n    dimmer = new Dimmer(this);\r\n    dimmer.longBright();\r\n\r\n    programmingModeManager = new ProgrammingModeManager();\r\n    programmingModeManager.register(new ProgrammingWebHandlers());\r\n    programmingModeManager.register(new OnBotJavaProgrammingMode());\r\n\r\n    updateUI = createUpdateUI();\r\n    callback = createUICallback(updateUI);\r\n\r\n    PreferenceManager.setDefaultValues(this, R.xml.app_settings, false);\r\n\r\n    WifiManager wifiManager = (WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE);\r\n    wifiLock = wifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL_HIGH_PERF, \"\");\r\n\r\n    hittingMenuButtonBrightensScreen();\r\n\r\n    wifiLock.acquire();\r\n    callback.networkConnectionUpdate(NetworkConnection.NetworkEvent.DISCONNECTED);\r\n    readNetworkType();\r\n    ServiceController.startService(FtcRobotControllerWatchdogService.class);\r\n    bindToService();\r\n    logPackageVersions();\r\n    logDeviceSerialNumber();\r\n    AndroidBoard.getInstance().logAndroidBoardInfo();\r\n    RobotLog.logDeviceInfo();\r\n\r\n    if (preferencesHelper.readBoolean(getString(R.string.pref_wifi_automute), false)) {\r\n      initWifiMute(true);\r\n    }\r\n\r\n    FtcAboutActivity.setBuildTimeFromBuildConfig(BuildConfig.BUILD_TIME);\r\n\r\n    // check to see if there is a preferred Wi-Fi to use.\r\n    checkPreferredChannel();\r\n\r\n    FtcDashboard.start();\r\n  }\r\n\r\n  protected UpdateUI createUpdateUI() {\r\n    Restarter restarter = new RobotRestarter();\r\n    UpdateUI result = new UpdateUI(this, dimmer);\r\n    result.setRestarter(restarter);\r\n    result.setTextViews(textNetworkConnectionStatus, textRobotStatus, textGamepad, textOpMode, textErrorMessage, textDeviceName);\r\n    return result;\r\n  }\r\n\r\n  protected UpdateUI.Callback createUICallback(UpdateUI updateUI) {\r\n    UpdateUI.Callback result = updateUI.new Callback();\r\n    result.setStateMonitor(new SoundPlayingRobotMonitor());\r\n    return result;\r\n  }\r\n\r\n  @Override\r\n  protected void onStart() {\r\n    super.onStart();\r\n    RobotLog.vv(TAG, \"onStart()\");\r\n\r\n    entireScreenLayout.setOnTouchListener(new View.OnTouchListener() {\r\n      @Override\r\n      public boolean onTouch(View v, MotionEvent event) {\r\n        dimmer.handleDimTimer();\r\n        return false;\r\n      }\r\n    });\r\n  }\r\n\r\n  @Override\r\n  protected void onResume() {\r\n    super.onResume();\r\n    RobotLog.vv(TAG, \"onResume()\");\r\n  }\r\n\r\n  @Override\r\n  protected void onPause() {\r\n    super.onPause();\r\n    RobotLog.vv(TAG, \"onPause()\");\r\n  }\r\n\r\n  @Override\r\n  protected void onStop() {\r\n    // Note: this gets called even when the configuration editor is launched. That is, it gets\r\n    // called surprisingly often. So, we don't actually do much here.\r\n    super.onStop();\r\n    RobotLog.vv(TAG, \"onStop()\");\r\n  }\r\n\r\n  @Override\r\n  protected void onDestroy() {\r\n    super.onDestroy();\r\n    RobotLog.vv(TAG, \"onDestroy()\");\r\n\r\n    shutdownRobot();  // Ensure the robot is put away to bed\r\n    if (callback != null) callback.close();\r\n\r\n    PreferenceRemoterRC.getInstance().stop(prefRemoterStartResult);\r\n    DeviceNameManagerFactory.getInstance().stop(deviceNameStartResult);\r\n\r\n    unbindFromService();\r\n    // If the app manually (?) is stopped, then we don't need the auto-starting function (?)\r\n    ServiceController.stopService(FtcRobotControllerWatchdogService.class);\r\n    if (wifiLock != null) wifiLock.release();\r\n    if (preferencesHelper != null) preferencesHelper.getSharedPreferences().unregisterOnSharedPreferenceChangeListener(sharedPreferencesListener);\r\n\r\n    RobotLog.cancelWriteLogcatToDisk();\r\n\r\n    FtcDashboard.stop();\r\n  }\r\n\r\n  protected void bindToService() {\r\n    readNetworkType();\r\n    Intent intent = new Intent(this, FtcRobotControllerService.class);\r\n    intent.putExtra(NetworkConnectionFactory.NETWORK_CONNECTION_TYPE, networkType);\r\n    serviceShouldUnbind = bindService(intent, connection, Context.BIND_AUTO_CREATE);\r\n  }\r\n\r\n  protected void unbindFromService() {\r\n    if (serviceShouldUnbind) {\r\n      unbindService(connection);\r\n      serviceShouldUnbind = false;\r\n    }\r\n  }\r\n\r\n  protected void logPackageVersions() {\r\n    RobotLog.logBuildConfig(com.qualcomm.ftcrobotcontroller.BuildConfig.class);\r\n    RobotLog.logBuildConfig(com.qualcomm.robotcore.BuildConfig.class);\r\n    RobotLog.logBuildConfig(com.qualcomm.hardware.BuildConfig.class);\r\n    RobotLog.logBuildConfig(com.qualcomm.ftccommon.BuildConfig.class);\r\n    RobotLog.logBuildConfig(com.google.blocks.BuildConfig.class);\r\n    RobotLog.logBuildConfig(org.firstinspires.inspection.BuildConfig.class);\r\n  }\r\n\r\n  protected void logDeviceSerialNumber() {\r\n    RobotLog.ii(TAG, \"Android device serial number: \" + Device.getSerialNumberOrUnknown());\r\n  }\r\n\r\n  protected void readNetworkType() {\r\n\r\n    // The code here used to defer to the value found in a configuration file\r\n    // to configure the network type. If the file was absent, then it initialized\r\n    // it with a default.\r\n    //\r\n    // However, bugs have been reported with that approach (empty config files, specifically).\r\n    // Moreover, the non-Wifi-Direct networking is end-of-life, so the simplest and most robust\r\n    // (e.g.: no one can screw things up by messing with the contents of the config file) fix is\r\n    // to do away with configuration file entirely.\r\n    //\r\n    // Control hubs are always running the access point model.  Everything else, for the time\r\n    // being always runs the wifi direct model.\r\n    if (Device.isRevControlHub() == true) {\r\n      networkType = NetworkType.RCWIRELESSAP;\r\n    } else {\r\n      networkType = NetworkType.fromString(preferencesHelper.readString(context.getString(R.string.pref_pairing_kind), NetworkType.globalDefaultAsString()));\r\n    }\r\n\r\n    // update the app_settings\r\n    preferencesHelper.writeStringPrefIfDifferent(context.getString(R.string.pref_pairing_kind), networkType.toString());\r\n  }\r\n\r\n  @Override\r\n  public void onWindowFocusChanged(boolean hasFocus) {\r\n    super.onWindowFocusChanged(hasFocus);\r\n\r\n    if (hasFocus) {\r\n      immersion.hideSystemUI();\r\n      getWindow().setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION, WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);\r\n    }\r\n  }\r\n\r\n  @Override\r\n  public boolean onCreateOptionsMenu(Menu menu) {\r\n    getMenuInflater().inflate(R.menu.ftc_robot_controller, menu);\r\n    FtcDashboard.populateMenu(menu);\r\n    return true;\r\n  }\r\n\r\n  private boolean isRobotRunning() {\r\n    if (controllerService == null) {\r\n      return false;\r\n    }\r\n\r\n    Robot robot = controllerService.getRobot();\r\n\r\n    if ((robot == null) || (robot.eventLoopManager == null)) {\r\n      return false;\r\n    }\r\n\r\n    RobotState robotState = robot.eventLoopManager.state;\r\n\r\n    if (robotState != RobotState.RUNNING) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  @Override\r\n  public boolean onOptionsItemSelected(MenuItem item) {\r\n    int id = item.getItemId();\r\n\r\n    if (id == R.id.action_program_and_manage) {\r\n      if (isRobotRunning()) {\r\n        Intent programmingModeIntent = new Intent(AppUtil.getDefContext(), ProgramAndManageActivity.class);\r\n        RobotControllerWebInfo webInfo = programmingModeManager.getWebServer().getConnectionInformation();\r\n        programmingModeIntent.putExtra(LaunchActivityConstantsList.RC_WEB_INFO, webInfo.toJson());\r\n        startActivity(programmingModeIntent);\r\n      } else {\r\n        AppUtil.getInstance().showToast(UILocation.ONLY_LOCAL, context.getString(R.string.toastWifiUpBeforeProgrammingMode));\r\n      }\r\n    } else if (id == R.id.action_inspection_mode) {\r\n      Intent inspectionModeIntent = new Intent(AppUtil.getDefContext(), RcInspectionActivity.class);\r\n      startActivity(inspectionModeIntent);\r\n      return true;\r\n    } else if (id == R.id.action_restart_robot) {\r\n      dimmer.handleDimTimer();\r\n      AppUtil.getInstance().showToast(UILocation.BOTH, context.getString(R.string.toastRestartingRobot));\r\n      requestRobotRestart();\r\n      return true;\r\n    }\r\n    else if (id == R.id.action_configure_robot) {\r\n      EditParameters parameters = new EditParameters();\r\n      Intent intentConfigure = new Intent(AppUtil.getDefContext(), FtcLoadFileActivity.class);\r\n      parameters.putIntent(intentConfigure);\r\n      startActivityForResult(intentConfigure, RequestCode.CONFIGURE_ROBOT_CONTROLLER.ordinal());\r\n    }\r\n    else if (id == R.id.action_settings) {\r\n\t  // historical: this once erroneously used FTC_CONFIGURE_REQUEST_CODE_ROBOT_CONTROLLER\r\n      Intent settingsIntent = new Intent(AppUtil.getDefContext(), FtcRobotControllerSettingsActivity.class);\r\n      startActivityForResult(settingsIntent, RequestCode.SETTINGS_ROBOT_CONTROLLER.ordinal());\r\n      return true;\r\n    }\r\n    else if (id == R.id.action_about) {\r\n      Intent intent = new Intent(AppUtil.getDefContext(), FtcAboutActivity.class);\r\n      startActivity(intent);\r\n      return true;\r\n    }\r\n    else if (id == R.id.action_exit_app) {\r\n\r\n      //Clear backstack and everything to prevent edge case where VM might be\r\n      //restarted (after it was exited) if more than one activity was on the\r\n      //backstack for some reason.\r\n      finishAffinity();\r\n\r\n      //For lollipop and up, we can clear ourselves from the recents list too\r\n      if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {\r\n        ActivityManager manager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);\r\n        List<ActivityManager.AppTask> tasks = manager.getAppTasks();\r\n\r\n        for (ActivityManager.AppTask task : tasks) {\r\n          task.finishAndRemoveTask();\r\n        }\r\n      }\r\n\r\n      // Allow the user to use the Control Hub operating system's UI, instead of relaunching the app\r\n      AppAliveNotifier.getInstance().disableAppWatchdogUntilNextAppStart();\r\n\r\n      //Finally, nuke the VM from orbit\r\n      AppUtil.getInstance().exitApplication();\r\n\r\n      return true;\r\n    }\r\n\r\n   return super.onOptionsItemSelected(item);\r\n  }\r\n\r\n  @Override\r\n  public void onConfigurationChanged(Configuration newConfig) {\r\n    super.onConfigurationChanged(newConfig);\r\n    // don't destroy assets on screen rotation\r\n    updateMonitorLayout(newConfig);\r\n  }\r\n\r\n  /**\r\n   * Updates the orientation of monitorContainer (which contains cameraMonitorView and\r\n   * tfodMonitorView) based on the given configuration. Makes the children split the space.\r\n   */\r\n  private void updateMonitorLayout(Configuration configuration) {\r\n    LinearLayout monitorContainer = (LinearLayout) findViewById(R.id.monitorContainer);\r\n    if (configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {\r\n      // When the phone is landscape, lay out the monitor views horizontally.\r\n      monitorContainer.setOrientation(LinearLayout.HORIZONTAL);\r\n      for (int i = 0; i < monitorContainer.getChildCount(); i++) {\r\n        View view = monitorContainer.getChildAt(i);\r\n        view.setLayoutParams(new LayoutParams(0, LayoutParams.MATCH_PARENT, 1 /* weight */));\r\n      }\r\n    } else {\r\n      // When the phone is portrait, lay out the monitor views vertically.\r\n      monitorContainer.setOrientation(LinearLayout.VERTICAL);\r\n      for (int i = 0; i < monitorContainer.getChildCount(); i++) {\r\n        View view = monitorContainer.getChildAt(i);\r\n        view.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, 0, 1 /* weight */));\r\n      }\r\n    }\r\n    monitorContainer.requestLayout();\r\n  }\r\n\r\n  @Override\r\n  protected void onActivityResult(int request, int result, Intent intent) {\r\n    if (request == REQUEST_CONFIG_WIFI_CHANNEL) {\r\n      if (result == RESULT_OK) {\r\n        AppUtil.getInstance().showToast(UILocation.BOTH, context.getString(R.string.toastWifiConfigurationComplete));\r\n      }\r\n    }\r\n    // was some historical confusion about launch codes here, so we err safely\r\n    if (request == RequestCode.CONFIGURE_ROBOT_CONTROLLER.ordinal() || request == RequestCode.SETTINGS_ROBOT_CONTROLLER.ordinal()) {\r\n      // We always do a refresh, whether it was a cancel or an OK, for robustness\r\n      shutdownRobot();\r\n      cfgFileMgr.getActiveConfigAndUpdateUI();\r\n      updateUIAndRequestRobotSetup();\r\n    }\r\n  }\r\n\r\n  public void onServiceBind(final FtcRobotControllerService service) {\r\n    RobotLog.vv(FtcRobotControllerService.TAG, \"%s.controllerService=bound\", TAG);\r\n    controllerService = service;\r\n    updateUI.setControllerService(controllerService);\r\n\r\n    updateUIAndRequestRobotSetup();\r\n    programmingModeManager.setState(new FtcRobotControllerServiceState() {\r\n      @NonNull\r\n      @Override\r\n      public WebServer getWebServer() {\r\n        return service.getWebServer();\r\n      }\r\n\r\n      @Override\r\n      public EventLoopManager getEventLoopManager() {\r\n        return service.getRobot().eventLoopManager;\r\n      }\r\n    });\r\n    FtcDashboard.attachWebServer(service.getWebServer());\r\n  }\r\n\r\n  private void updateUIAndRequestRobotSetup() {\r\n    if (controllerService != null) {\r\n      callback.networkConnectionUpdate(controllerService.getNetworkConnectionStatus());\r\n      callback.updateRobotStatus(controllerService.getRobotStatus());\r\n      // Only show this first-time toast on headless systems: what we have now on non-headless suffices\r\n      requestRobotSetup(LynxConstants.isRevControlHub()\r\n        ? new Runnable() {\r\n            @Override public void run() {\r\n              showRestartRobotCompleteToast(R.string.toastRobotSetupComplete);\r\n            }\r\n          }\r\n        : null);\r\n    }\r\n    FtcDashboard.attachEventLoop(eventLoop);\r\n  }\r\n\r\n  private void requestRobotSetup(@Nullable Runnable runOnComplete) {\r\n    if (controllerService == null) return;\r\n\r\n    RobotConfigFile file = cfgFileMgr.getActiveConfigAndUpdateUI();\r\n    HardwareFactory hardwareFactory = new HardwareFactory(context);\r\n    try {\r\n      hardwareFactory.setXmlPullParser(file.getXml());\r\n    } catch (Resources.NotFoundException e) {\r\n      file = RobotConfigFile.noConfig(cfgFileMgr);\r\n      hardwareFactory.setXmlPullParser(file.getXml());\r\n      cfgFileMgr.setActiveConfigAndUpdateUI(false, file);\r\n    }\r\n\r\n    OpModeRegister userOpModeRegister = createOpModeRegister();\r\n    eventLoop = new FtcEventLoop(hardwareFactory, userOpModeRegister, callback, this);\r\n    FtcEventLoopIdle idleLoop = new FtcEventLoopIdle(hardwareFactory, userOpModeRegister, callback, this);\r\n\r\n    controllerService.setCallback(callback);\r\n    controllerService.setupRobot(eventLoop, idleLoop, runOnComplete);\r\n\r\n    passReceivedUsbAttachmentsToEventLoop();\r\n    AndroidBoard.showErrorIfUnknownControlHub();\r\n  }\r\n\r\n  protected OpModeRegister createOpModeRegister() {\r\n    return new FtcOpModeRegister();\r\n  }\r\n\r\n  private void shutdownRobot() {\r\n    if (controllerService != null) controllerService.shutdownRobot();\r\n  }\r\n\r\n  private void requestRobotRestart() {\r\n    AppUtil.getInstance().showToast(UILocation.BOTH, AppUtil.getDefContext().getString(R.string.toastRestartingRobot));\r\n    //\r\n    RobotLog.clearGlobalErrorMsg();\r\n    RobotLog.clearGlobalWarningMsg();\r\n    shutdownRobot();\r\n    requestRobotSetup(new Runnable() {\r\n      @Override public void run() {\r\n        showRestartRobotCompleteToast(R.string.toastRestartRobotComplete);\r\n        }\r\n      });\r\n  }\r\n\r\n  private void showRestartRobotCompleteToast(@StringRes int resid) {\r\n    AppUtil.getInstance().showToast(UILocation.BOTH, AppUtil.getDefContext().getString(resid));\r\n  }\r\n\r\n  private void checkPreferredChannel() {\r\n    // For P2P network, check to see what preferred channel is.\r\n    if (networkType ==  NetworkType.WIFIDIRECT) {\r\n      int prefChannel = preferencesHelper.readInt(getString(com.qualcomm.ftccommon.R.string.pref_wifip2p_channel), -1);\r\n      if (prefChannel == -1) {\r\n        prefChannel = 0;\r\n        RobotLog.vv(TAG, \"pref_wifip2p_channel: No preferred channel defined. Will use a default value of %d\", prefChannel);\r\n      } else {\r\n        RobotLog.vv(TAG, \"pref_wifip2p_channel: Found existing preferred channel (%d).\", prefChannel);\r\n      }\r\n\r\n      // attempt to set the preferred channel.\r\n      RobotLog.vv(TAG, \"pref_wifip2p_channel: attempting to set preferred channel...\");\r\n      wifiDirectChannelChanger = new WifiDirectChannelChanger();\r\n      wifiDirectChannelChanger.changeToChannel(prefChannel);\r\n    }\r\n  }\r\n\r\n  protected void hittingMenuButtonBrightensScreen() {\r\n    ActionBar actionBar = getActionBar();\r\n    if (actionBar != null) {\r\n      actionBar.addOnMenuVisibilityListener(new ActionBar.OnMenuVisibilityListener() {\r\n        @Override\r\n        public void onMenuVisibilityChanged(boolean isVisible) {\r\n          if (isVisible) {\r\n            dimmer.handleDimTimer();\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  protected class SharedPreferencesListener implements SharedPreferences.OnSharedPreferenceChangeListener {\r\n    @Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {\r\n      if (key.equals(context.getString(R.string.pref_app_theme))) {\r\n        ThemedActivity.restartForAppThemeChange(getTag(), getString(R.string.appThemeChangeRestartNotifyRC));\r\n      } else if (key.equals(context.getString(R.string.pref_wifi_automute))) {\r\n        if (preferencesHelper.readBoolean(context.getString(R.string.pref_wifi_automute), false)) {\r\n          initWifiMute(true);\r\n        } else {\r\n          initWifiMute(false);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  protected void initWifiMute(boolean enable) {\r\n    if (enable) {\r\n      wifiMuteStateMachine = new WifiMuteStateMachine();\r\n      wifiMuteStateMachine.initialize();\r\n      wifiMuteStateMachine.start();\r\n\r\n      motionDetection = new MotionDetection(2.0, 10);\r\n      motionDetection.startListening();\r\n      motionDetection.registerListener(new MotionDetection.MotionDetectionListener() {\r\n        @Override\r\n        public void onMotionDetected(double vector)\r\n        {\r\n          wifiMuteStateMachine.consumeEvent(WifiMuteEvent.USER_ACTIVITY);\r\n        }\r\n      });\r\n    } else {\r\n      wifiMuteStateMachine.stop();\r\n      wifiMuteStateMachine = null;\r\n      motionDetection.stopListening();\r\n      motionDetection.purgeListeners();\r\n      motionDetection = null;\r\n    }\r\n  }\r\n\r\n  @Override\r\n  public void onUserInteraction() {\r\n    if (wifiMuteStateMachine != null) {\r\n      wifiMuteStateMachine.consumeEvent(WifiMuteEvent.USER_ACTIVITY);\r\n    }\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/internal/FtcRobotControllerActivity.java	(revision 083306be81e2ceff03f843347df005b323a54ab6)
+++ FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/internal/FtcRobotControllerActivity.java	(date 1635345029094)
@@ -85,6 +85,7 @@
 import com.qualcomm.hardware.HardwareFactory;
 import com.qualcomm.robotcore.eventloop.EventLoopManager;
 import com.qualcomm.robotcore.eventloop.opmode.FtcRobotControllerServiceState;
+import com.qualcomm.robotcore.eventloop.opmode.OpModeManager;
 import com.qualcomm.robotcore.eventloop.opmode.OpModeRegister;
 import com.qualcomm.robotcore.hardware.configuration.LynxConstants;
 import com.qualcomm.robotcore.hardware.configuration.Utility;
@@ -724,7 +725,12 @@
   }
 
   protected OpModeRegister createOpModeRegister() {
-    return new FtcOpModeRegister();
+    return new OpModeRegister() {
+      @Override
+      public void register(OpModeManager manager) {
+
+      }
+    };
   }
 
   private void shutdownRobot() {
